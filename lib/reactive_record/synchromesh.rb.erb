module ReactiveRecord

  class Synchromesh

    include React::IsomorphicHelpers

    def self.sync_change(data)
      Base.when_not_saving(Object.const_get(data[:klass])) do |klass|
        klass._react_param_conversion(data[:record]).backing_record.sync_scopes
      end
    end

    def self.sync_destroy(data)
      record = Object.const_get(data[:klass])._react_param_conversion(data[:record])
      ReactiveRecord::Base.load_data { record.destroy }
      record.backing_record.destroyed = true
      record.backing_record.sync_scopes
    end

    before_first_mount do |context|
      if on_opal_client?
        puts "setting up synchromesh on client: <%= Synchromesh.transport %> time now = <%= Time.now %>"

        <% if Synchromesh.transport == :pusher %>

          change = lambda do |data|
            sync_change Hash.new(data)
          end

          destroy = lambda do |data|
            sync_destroy Hash.new(data)
          end

          %x{
            <% if Synchromesh.client_logging %>
            Pusher.log = function(message) {
              if (window.console && window.console.log) {
                window.console.log(message);
              }
            };
            <% end %>

            <% if defined?(PusherFake) %>
              var pusher = <%= PusherFake.javascript %>;
            <% else %>
              var pusher = new Pusher('<%= Synchromesh.key %>', {
                encrypted: <%= Synchromesh.encrypted %>
              });
            <% end %>

            var channel = pusher.subscribe('<%= Synchromesh.channel %>');
            channel.bind('change', change);
            channel.bind('destroy', destroy);
          }

        <% elsif Synchromesh.transport == :simple_poller %>

          id = nil

          HTTP.get(`window.ReactiveRecordEnginePath`+"/syncromesh-subscribe/").then do |response|
            id = response.json[:id]
          end

          puts "SECONDS BETWEEN POLL SET TO <%= Synchromesh.seconds_between_poll %> SECONDS"

          every(<%= Synchromesh.seconds_between_poll %>) do
            HTTP.get(`window.ReactiveRecordEnginePath`+"/syncromesh-read/#{id}").then do |response|
              response.json.each do |update|
                case update[0]
                when :change
                  sync_change update[1]
                when :destroy
                  sync_destroy update[1]
                end
              end
            end
          end

        <% end %>

      end
    end
  end
end
