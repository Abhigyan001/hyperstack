require 'pry'
module HyperSpec
  # Defines a series of methods that will build a test page
  # This module is typically included into the HyperSpecTestController class.
  module ControllerHelpers

    # These methods are dependent on the stack being used.  See the
    # RailsControllerHelpers module and rack.rb for two implementations.
    # Each method should append the appropriate data to the @page variable

    # return an empty 204 status
    # either by setting headers or returning and appropriate response for rack.
    def ping!
      raise 'must implement'
    end

    # return a script or style_sheet tag pointing to the application js code.
    # typically you be pointing to a path on the server or using
    # sprockets to deliver the file.

    def application!(_file_)
      raise 'must implement'
    end

    def style_sheet!(_file_)
      raise 'must implement'
    end

    # deliver the page.  The @page variable will contain the html ready to go,
    # any additional options that are passed through from the spec will be
    # in the @render_params variable.  For example layout: 'my special layout'

    def deliver!
      raise 'must implement'
    end

    # generate a react_render top level block.  This will only be called if
    # you use the mount directive in your specs, so it is optional.

    def mount_component!
      raise 'mount_component not implemented in HyperSpecTestController'
    end

    # by default the route back to the controller will be the controller name, less the
    # word Controller, and underscored.  If you want some other name redefine this
    # method in the HyperSpecController class.

    def self.included(base)
      def base.route_root
        # Implement underscore without using rails underscore, so we don't have a
        # dependency on ActiveSupport
        name.gsub(/Controller$/, '')
            .gsub(/::/, '/')
            .gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
            .gsub(/([a-z\d])([A-Z])/, '\1_\2')
            .tr('-', '_')
            .downcase
      end
    end

    # The remainder of the methods should work for most implementations.

    # helper method checking the render_on parameter

    def server_only?
      @render_on == :server_only
    end

    # The controllers behavior is kept as an array of values in the ComponentTestHelpers cache
    # under a unique id for each test run.  Grab the parameters and move them to instance vars

    # If this is just a ping! Then we can just exit with nil.

    def initialize!
      return if params[:id] == 'ping'

      key =               "/#{self.class.route_root}/#{params[:id]}"
      test_params =       ComponentTestHelpers.cache_read(key)

      @component_name =   test_params[0]
      @component_params = test_params[1]
      @html_block =       test_params[2]
      @render_params =    test_params[3]
      @render_on =        @render_params.delete(:render_on) || :client_only
      @_mock_time =       @render_params.delete(:mock_time)
      @style_sheet =      @render_params.delete(:style_sheet)
      @javascript =       @render_params.delete(:javascript)
      @code =             @render_params.delete(:code)

      @page = "</body>\n"
    end

    # add any html code generated by the insert_html directive

    def html_block!
      @page = "<body>\n#{@html_block}\n#{@page}"
    end

    # patch behavior of the HyperComponent TopLevelRailsComponent class
    # so that things like events are passed back to the test harness
    TOP_LEVEL_COMPONENT_PATCH =
      Opal.compile(File.read(File.expand_path('../../sources/top_level_rails_component.rb', __FILE__)))

    # patch time cop and lolex so they stay in sync across the client and server
    TIME_COP_CLIENT_PATCH =
      Opal.compile(File.read(File.expand_path('../../hyper-spec/time_cop.rb', __FILE__))) +
      "\n#{File.read(File.expand_path('../../sources/lolex.js', __FILE__))}"

    def client_code!
      if @component_name
        @page = "<script type='text/javascript'>\n#{TOP_LEVEL_COMPONENT_PATCH}\n</script>\n#{@page}"
      end
      @page = "<script type='text/javascript'>\n#{@code}\n</script>\n#{@page}" if @code
    end

    def time_cop_patch!
      @page = "<script type='text/javascript'>\n#{TIME_COP_CLIENT_PATCH}\n</script>\n#{@page}"
    end

    # Add the go_function to the client console.  This is used to stop a hyper-spec pause directive.

    def go_function!
      @page = "<script type='text/javascript'>go = function() "\
              "{window.hyper_spec_waiting_for_go = false}</script>\n#{@page}"
    end

    # First lines displayed on the console will be the name of the spec

    def example_title!
      title = ComponentTestHelpers.current_example_description!
      @page = "<script type='text/javascript'>console.log('%c#{title}',"\
              "'color:green; font-weight:bold; font-size: 200%')</script>\n#{@page}"
    end

    # generate each piece of the page, and then deliver it

    def test
      return ping! unless initialize!

      # TODO: reverse the the layout in the above methods so they can run in
      # the right order
      mount_component! if @component_name
      client_code!     unless server_only?
      time_cop_patch!  if !server_only? || Lolex.initialized?
      application!(@javascript || 'application')  if (!server_only? && !@render_params[:layout]) || @javascript
      style_sheet!(@style_sheet || 'application') if !@render_params[:layout] || @style_sheet
      go_function!
      example_title!   if ComponentTestHelpers.current_example
      html_block!
      deliver!
    end
  end
end
